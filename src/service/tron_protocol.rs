// This file is @generated by prost-build.
/// AccountId, (name, address) use name, (null, address) use address, (name, null) use name,
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AccountId {
    #[prost(bytes = "vec", tag = "1")]
    pub name: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "2")]
    pub address: ::prost::alloc::vec::Vec<u8>,
}
/// vote message
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Vote {
    /// the super rep address
    #[prost(bytes = "vec", tag = "1")]
    pub vote_address: ::prost::alloc::vec::Vec<u8>,
    /// the vote num to this super rep.
    #[prost(int64, tag = "2")]
    pub vote_count: i64,
}
/// Proposal
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Proposal {
    #[prost(int64, tag = "1")]
    pub proposal_id: i64,
    #[prost(bytes = "vec", tag = "2")]
    pub proposer_address: ::prost::alloc::vec::Vec<u8>,
    #[prost(map = "int64, int64", tag = "3")]
    pub parameters: ::std::collections::HashMap<i64, i64>,
    #[prost(int64, tag = "4")]
    pub expiration_time: i64,
    #[prost(int64, tag = "5")]
    pub create_time: i64,
    #[prost(bytes = "vec", repeated, tag = "6")]
    pub approvals: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    #[prost(enumeration = "proposal::State", tag = "7")]
    pub state: i32,
}
/// Nested message and enum types in `Proposal`.
pub mod proposal {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        Pending = 0,
        Disapproved = 1,
        Approved = 2,
        Canceled = 3,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Pending => "PENDING",
                Self::Disapproved => "DISAPPROVED",
                Self::Approved => "APPROVED",
                Self::Canceled => "CANCELED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PENDING" => Some(Self::Pending),
                "DISAPPROVED" => Some(Self::Disapproved),
                "APPROVED" => Some(Self::Approved),
                "CANCELED" => Some(Self::Canceled),
                _ => None,
            }
        }
    }
}
/// Exchange
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Exchange {
    #[prost(int64, tag = "1")]
    pub exchange_id: i64,
    #[prost(bytes = "vec", tag = "2")]
    pub creator_address: ::prost::alloc::vec::Vec<u8>,
    #[prost(int64, tag = "3")]
    pub create_time: i64,
    #[prost(bytes = "vec", tag = "6")]
    pub first_token_id: ::prost::alloc::vec::Vec<u8>,
    #[prost(int64, tag = "7")]
    pub first_token_balance: i64,
    #[prost(bytes = "vec", tag = "8")]
    pub second_token_id: ::prost::alloc::vec::Vec<u8>,
    #[prost(int64, tag = "9")]
    pub second_token_balance: i64,
}
/// market
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MarketOrder {
    #[prost(bytes = "vec", tag = "1")]
    pub order_id: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "2")]
    pub owner_address: ::prost::alloc::vec::Vec<u8>,
    #[prost(int64, tag = "3")]
    pub create_time: i64,
    #[prost(bytes = "vec", tag = "4")]
    pub sell_token_id: ::prost::alloc::vec::Vec<u8>,
    #[prost(int64, tag = "5")]
    pub sell_token_quantity: i64,
    #[prost(bytes = "vec", tag = "6")]
    pub buy_token_id: ::prost::alloc::vec::Vec<u8>,
    /// min to receive
    #[prost(int64, tag = "7")]
    pub buy_token_quantity: i64,
    #[prost(int64, tag = "9")]
    pub sell_token_quantity_remain: i64,
    /// When state != ACTIVE and sell_token_quantity_return !=0,
    /// it means that some sell tokens are returned to the account due to insufficient remaining amount
    #[prost(int64, tag = "10")]
    pub sell_token_quantity_return: i64,
    #[prost(enumeration = "market_order::State", tag = "11")]
    pub state: i32,
    #[prost(bytes = "vec", tag = "12")]
    pub prev: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "13")]
    pub next: ::prost::alloc::vec::Vec<u8>,
}
/// Nested message and enum types in `MarketOrder`.
pub mod market_order {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        Active = 0,
        Inactive = 1,
        Canceled = 2,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Active => "ACTIVE",
                Self::Inactive => "INACTIVE",
                Self::Canceled => "CANCELED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ACTIVE" => Some(Self::Active),
                "INACTIVE" => Some(Self::Inactive),
                "CANCELED" => Some(Self::Canceled),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MarketOrderList {
    #[prost(message, repeated, tag = "1")]
    pub orders: ::prost::alloc::vec::Vec<MarketOrder>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MarketOrderPairList {
    #[prost(message, repeated, tag = "1")]
    pub order_pair: ::prost::alloc::vec::Vec<MarketOrderPair>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MarketOrderPair {
    #[prost(bytes = "vec", tag = "1")]
    pub sell_token_id: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "2")]
    pub buy_token_id: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MarketAccountOrder {
    #[prost(bytes = "vec", tag = "1")]
    pub owner_address: ::prost::alloc::vec::Vec<u8>,
    /// order_id list
    #[prost(bytes = "vec", repeated, tag = "2")]
    pub orders: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    /// active count
    #[prost(int64, tag = "3")]
    pub count: i64,
    #[prost(int64, tag = "4")]
    pub total_count: i64,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MarketPrice {
    #[prost(int64, tag = "1")]
    pub sell_token_quantity: i64,
    #[prost(int64, tag = "2")]
    pub buy_token_quantity: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MarketPriceList {
    #[prost(bytes = "vec", tag = "1")]
    pub sell_token_id: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "2")]
    pub buy_token_id: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, repeated, tag = "3")]
    pub prices: ::prost::alloc::vec::Vec<MarketPrice>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MarketOrderIdList {
    #[prost(bytes = "vec", tag = "1")]
    pub head: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "2")]
    pub tail: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChainParameters {
    #[prost(message, repeated, tag = "1")]
    pub chain_parameter: ::prost::alloc::vec::Vec<chain_parameters::ChainParameter>,
}
/// Nested message and enum types in `ChainParameters`.
pub mod chain_parameters {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ChainParameter {
        #[prost(string, tag = "1")]
        pub key: ::prost::alloc::string::String,
        #[prost(int64, tag = "2")]
        pub value: i64,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Key {
    #[prost(bytes = "vec", tag = "1")]
    pub address: ::prost::alloc::vec::Vec<u8>,
    #[prost(int64, tag = "2")]
    pub weight: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DelegatedResource {
    #[prost(bytes = "vec", tag = "1")]
    pub from: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "2")]
    pub to: ::prost::alloc::vec::Vec<u8>,
    #[prost(int64, tag = "3")]
    pub frozen_balance_for_bandwidth: i64,
    #[prost(int64, tag = "4")]
    pub frozen_balance_for_energy: i64,
    #[prost(int64, tag = "5")]
    pub expire_time_for_bandwidth: i64,
    #[prost(int64, tag = "6")]
    pub expire_time_for_energy: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Authority {
    #[prost(message, optional, tag = "1")]
    pub account: ::core::option::Option<AccountId>,
    #[prost(bytes = "vec", tag = "2")]
    pub permission_name: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Permission {
    #[prost(enumeration = "permission::PermissionType", tag = "1")]
    pub r#type: i32,
    /// Owner id=0, Witness id=1, Active id start by 2
    #[prost(int32, tag = "2")]
    pub id: i32,
    #[prost(string, tag = "3")]
    pub permission_name: ::prost::alloc::string::String,
    #[prost(int64, tag = "4")]
    pub threshold: i64,
    #[prost(int32, tag = "5")]
    pub parent_id: i32,
    /// 1 bit 1 contract
    #[prost(bytes = "vec", tag = "6")]
    pub operations: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, repeated, tag = "7")]
    pub keys: ::prost::alloc::vec::Vec<Key>,
}
/// Nested message and enum types in `Permission`.
pub mod permission {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PermissionType {
        Owner = 0,
        Witness = 1,
        Active = 2,
    }
    impl PermissionType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Owner => "Owner",
                Self::Witness => "Witness",
                Self::Active => "Active",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "Owner" => Some(Self::Owner),
                "Witness" => Some(Self::Witness),
                "Active" => Some(Self::Active),
                _ => None,
            }
        }
    }
}
/// Witness
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Witness {
    #[prost(bytes = "vec", tag = "1")]
    pub address: ::prost::alloc::vec::Vec<u8>,
    #[prost(int64, tag = "2")]
    pub vote_count: i64,
    #[prost(bytes = "vec", tag = "3")]
    pub pub_key: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, tag = "4")]
    pub url: ::prost::alloc::string::String,
    #[prost(int64, tag = "5")]
    pub total_produced: i64,
    #[prost(int64, tag = "6")]
    pub total_missed: i64,
    #[prost(int64, tag = "7")]
    pub latest_block_num: i64,
    #[prost(int64, tag = "8")]
    pub latest_slot_num: i64,
    #[prost(bool, tag = "9")]
    pub is_jobs: bool,
}
/// Vote Change
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Votes {
    #[prost(bytes = "vec", tag = "1")]
    pub address: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, repeated, tag = "2")]
    pub old_votes: ::prost::alloc::vec::Vec<Vote>,
    #[prost(message, repeated, tag = "3")]
    pub new_votes: ::prost::alloc::vec::Vec<Vote>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TxOutput {
    #[prost(int64, tag = "1")]
    pub value: i64,
    #[prost(bytes = "vec", tag = "2")]
    pub pub_key_hash: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TxInput {
    #[prost(message, optional, tag = "1")]
    pub raw_data: ::core::option::Option<tx_input::Raw>,
    #[prost(bytes = "vec", tag = "4")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
}
/// Nested message and enum types in `TXInput`.
pub mod tx_input {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Raw {
        #[prost(bytes = "vec", tag = "1")]
        pub tx_id: ::prost::alloc::vec::Vec<u8>,
        #[prost(int64, tag = "2")]
        pub vout: i64,
        #[prost(bytes = "vec", tag = "3")]
        pub pub_key: ::prost::alloc::vec::Vec<u8>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TxOutputs {
    #[prost(message, repeated, tag = "1")]
    pub outputs: ::prost::alloc::vec::Vec<TxOutput>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ResourceReceipt {
    #[prost(int64, tag = "1")]
    pub energy_usage: i64,
    #[prost(int64, tag = "2")]
    pub energy_fee: i64,
    #[prost(int64, tag = "3")]
    pub origin_energy_usage: i64,
    #[prost(int64, tag = "4")]
    pub energy_usage_total: i64,
    #[prost(int64, tag = "5")]
    pub net_usage: i64,
    #[prost(int64, tag = "6")]
    pub net_fee: i64,
    #[prost(enumeration = "transaction::result::ContractResult", tag = "7")]
    pub result: i32,
    #[prost(int64, tag = "8")]
    pub energy_penalty_total: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MarketOrderDetail {
    #[prost(bytes = "vec", tag = "1")]
    pub maker_order_id: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "2")]
    pub taker_order_id: ::prost::alloc::vec::Vec<u8>,
    #[prost(int64, tag = "3")]
    pub fill_sell_quantity: i64,
    #[prost(int64, tag = "4")]
    pub fill_buy_quantity: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Transaction {
    #[prost(message, optional, tag = "1")]
    pub raw_data: ::core::option::Option<transaction::Raw>,
    /// only support size = 1,  repeated list here for muti-sig extension
    #[prost(bytes = "vec", repeated, tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    #[prost(message, repeated, tag = "5")]
    pub ret: ::prost::alloc::vec::Vec<transaction::Result>,
}
/// Nested message and enum types in `Transaction`.
pub mod transaction {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Contract {
        #[prost(enumeration = "contract::ContractType", tag = "1")]
        pub r#type: i32,
        #[prost(message, optional, tag = "2")]
        pub parameter: ::core::option::Option<::prost_types::Any>,
        #[prost(bytes = "vec", tag = "3")]
        pub provider: ::prost::alloc::vec::Vec<u8>,
        #[prost(bytes = "vec", tag = "4")]
        pub contract_name: ::prost::alloc::vec::Vec<u8>,
        #[prost(int32, tag = "5")]
        pub permission_id: i32,
    }
    /// Nested message and enum types in `Contract`.
    pub mod contract {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum ContractType {
            AccountCreateContract = 0,
            TransferContract = 1,
            TransferAssetContract = 2,
            VoteAssetContract = 3,
            VoteWitnessContract = 4,
            WitnessCreateContract = 5,
            AssetIssueContract = 6,
            WitnessUpdateContract = 8,
            ParticipateAssetIssueContract = 9,
            AccountUpdateContract = 10,
            FreezeBalanceContract = 11,
            UnfreezeBalanceContract = 12,
            WithdrawBalanceContract = 13,
            UnfreezeAssetContract = 14,
            UpdateAssetContract = 15,
            ProposalCreateContract = 16,
            ProposalApproveContract = 17,
            ProposalDeleteContract = 18,
            SetAccountIdContract = 19,
            CustomContract = 20,
            CreateSmartContract = 30,
            TriggerSmartContract = 31,
            GetContract = 32,
            UpdateSettingContract = 33,
            ExchangeCreateContract = 41,
            ExchangeInjectContract = 42,
            ExchangeWithdrawContract = 43,
            ExchangeTransactionContract = 44,
            UpdateEnergyLimitContract = 45,
            AccountPermissionUpdateContract = 46,
            ClearAbiContract = 48,
            UpdateBrokerageContract = 49,
            ShieldedTransferContract = 51,
            MarketSellAssetContract = 52,
            MarketCancelOrderContract = 53,
            FreezeBalanceV2Contract = 54,
            UnfreezeBalanceV2Contract = 55,
            WithdrawExpireUnfreezeContract = 56,
            DelegateResourceContract = 57,
            UnDelegateResourceContract = 58,
            CancelAllUnfreezeV2Contract = 59,
        }
        impl ContractType {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::AccountCreateContract => "AccountCreateContract",
                    Self::TransferContract => "TransferContract",
                    Self::TransferAssetContract => "TransferAssetContract",
                    Self::VoteAssetContract => "VoteAssetContract",
                    Self::VoteWitnessContract => "VoteWitnessContract",
                    Self::WitnessCreateContract => "WitnessCreateContract",
                    Self::AssetIssueContract => "AssetIssueContract",
                    Self::WitnessUpdateContract => "WitnessUpdateContract",
                    Self::ParticipateAssetIssueContract => {
                        "ParticipateAssetIssueContract"
                    }
                    Self::AccountUpdateContract => "AccountUpdateContract",
                    Self::FreezeBalanceContract => "FreezeBalanceContract",
                    Self::UnfreezeBalanceContract => "UnfreezeBalanceContract",
                    Self::WithdrawBalanceContract => "WithdrawBalanceContract",
                    Self::UnfreezeAssetContract => "UnfreezeAssetContract",
                    Self::UpdateAssetContract => "UpdateAssetContract",
                    Self::ProposalCreateContract => "ProposalCreateContract",
                    Self::ProposalApproveContract => "ProposalApproveContract",
                    Self::ProposalDeleteContract => "ProposalDeleteContract",
                    Self::SetAccountIdContract => "SetAccountIdContract",
                    Self::CustomContract => "CustomContract",
                    Self::CreateSmartContract => "CreateSmartContract",
                    Self::TriggerSmartContract => "TriggerSmartContract",
                    Self::GetContract => "GetContract",
                    Self::UpdateSettingContract => "UpdateSettingContract",
                    Self::ExchangeCreateContract => "ExchangeCreateContract",
                    Self::ExchangeInjectContract => "ExchangeInjectContract",
                    Self::ExchangeWithdrawContract => "ExchangeWithdrawContract",
                    Self::ExchangeTransactionContract => "ExchangeTransactionContract",
                    Self::UpdateEnergyLimitContract => "UpdateEnergyLimitContract",
                    Self::AccountPermissionUpdateContract => {
                        "AccountPermissionUpdateContract"
                    }
                    Self::ClearAbiContract => "ClearABIContract",
                    Self::UpdateBrokerageContract => "UpdateBrokerageContract",
                    Self::ShieldedTransferContract => "ShieldedTransferContract",
                    Self::MarketSellAssetContract => "MarketSellAssetContract",
                    Self::MarketCancelOrderContract => "MarketCancelOrderContract",
                    Self::FreezeBalanceV2Contract => "FreezeBalanceV2Contract",
                    Self::UnfreezeBalanceV2Contract => "UnfreezeBalanceV2Contract",
                    Self::WithdrawExpireUnfreezeContract => {
                        "WithdrawExpireUnfreezeContract"
                    }
                    Self::DelegateResourceContract => "DelegateResourceContract",
                    Self::UnDelegateResourceContract => "UnDelegateResourceContract",
                    Self::CancelAllUnfreezeV2Contract => "CancelAllUnfreezeV2Contract",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "AccountCreateContract" => Some(Self::AccountCreateContract),
                    "TransferContract" => Some(Self::TransferContract),
                    "TransferAssetContract" => Some(Self::TransferAssetContract),
                    "VoteAssetContract" => Some(Self::VoteAssetContract),
                    "VoteWitnessContract" => Some(Self::VoteWitnessContract),
                    "WitnessCreateContract" => Some(Self::WitnessCreateContract),
                    "AssetIssueContract" => Some(Self::AssetIssueContract),
                    "WitnessUpdateContract" => Some(Self::WitnessUpdateContract),
                    "ParticipateAssetIssueContract" => {
                        Some(Self::ParticipateAssetIssueContract)
                    }
                    "AccountUpdateContract" => Some(Self::AccountUpdateContract),
                    "FreezeBalanceContract" => Some(Self::FreezeBalanceContract),
                    "UnfreezeBalanceContract" => Some(Self::UnfreezeBalanceContract),
                    "WithdrawBalanceContract" => Some(Self::WithdrawBalanceContract),
                    "UnfreezeAssetContract" => Some(Self::UnfreezeAssetContract),
                    "UpdateAssetContract" => Some(Self::UpdateAssetContract),
                    "ProposalCreateContract" => Some(Self::ProposalCreateContract),
                    "ProposalApproveContract" => Some(Self::ProposalApproveContract),
                    "ProposalDeleteContract" => Some(Self::ProposalDeleteContract),
                    "SetAccountIdContract" => Some(Self::SetAccountIdContract),
                    "CustomContract" => Some(Self::CustomContract),
                    "CreateSmartContract" => Some(Self::CreateSmartContract),
                    "TriggerSmartContract" => Some(Self::TriggerSmartContract),
                    "GetContract" => Some(Self::GetContract),
                    "UpdateSettingContract" => Some(Self::UpdateSettingContract),
                    "ExchangeCreateContract" => Some(Self::ExchangeCreateContract),
                    "ExchangeInjectContract" => Some(Self::ExchangeInjectContract),
                    "ExchangeWithdrawContract" => Some(Self::ExchangeWithdrawContract),
                    "ExchangeTransactionContract" => {
                        Some(Self::ExchangeTransactionContract)
                    }
                    "UpdateEnergyLimitContract" => Some(Self::UpdateEnergyLimitContract),
                    "AccountPermissionUpdateContract" => {
                        Some(Self::AccountPermissionUpdateContract)
                    }
                    "ClearABIContract" => Some(Self::ClearAbiContract),
                    "UpdateBrokerageContract" => Some(Self::UpdateBrokerageContract),
                    "ShieldedTransferContract" => Some(Self::ShieldedTransferContract),
                    "MarketSellAssetContract" => Some(Self::MarketSellAssetContract),
                    "MarketCancelOrderContract" => Some(Self::MarketCancelOrderContract),
                    "FreezeBalanceV2Contract" => Some(Self::FreezeBalanceV2Contract),
                    "UnfreezeBalanceV2Contract" => Some(Self::UnfreezeBalanceV2Contract),
                    "WithdrawExpireUnfreezeContract" => {
                        Some(Self::WithdrawExpireUnfreezeContract)
                    }
                    "DelegateResourceContract" => Some(Self::DelegateResourceContract),
                    "UnDelegateResourceContract" => {
                        Some(Self::UnDelegateResourceContract)
                    }
                    "CancelAllUnfreezeV2Contract" => {
                        Some(Self::CancelAllUnfreezeV2Contract)
                    }
                    _ => None,
                }
            }
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Result {
        #[prost(int64, tag = "1")]
        pub fee: i64,
        #[prost(enumeration = "result::Code", tag = "2")]
        pub ret: i32,
        #[prost(enumeration = "result::ContractResult", tag = "3")]
        pub contract_ret: i32,
        #[prost(string, tag = "14")]
        pub asset_issue_id: ::prost::alloc::string::String,
        #[prost(int64, tag = "15")]
        pub withdraw_amount: i64,
        #[prost(int64, tag = "16")]
        pub unfreeze_amount: i64,
        #[prost(int64, tag = "18")]
        pub exchange_received_amount: i64,
        #[prost(int64, tag = "19")]
        pub exchange_inject_another_amount: i64,
        #[prost(int64, tag = "20")]
        pub exchange_withdraw_another_amount: i64,
        #[prost(int64, tag = "21")]
        pub exchange_id: i64,
        #[prost(int64, tag = "22")]
        pub shielded_transaction_fee: i64,
        #[prost(bytes = "vec", tag = "25")]
        pub order_id: ::prost::alloc::vec::Vec<u8>,
        #[prost(message, repeated, tag = "26")]
        pub order_details: ::prost::alloc::vec::Vec<super::MarketOrderDetail>,
        #[prost(int64, tag = "27")]
        pub withdraw_expire_amount: i64,
        #[prost(map = "string, int64", tag = "28")]
        pub cancel_unfreeze_v2_amount: ::std::collections::HashMap<
            ::prost::alloc::string::String,
            i64,
        >,
    }
    /// Nested message and enum types in `Result`.
    pub mod result {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Code {
            Sucess = 0,
            Failed = 1,
        }
        impl Code {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Sucess => "SUCESS",
                    Self::Failed => "FAILED",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "SUCESS" => Some(Self::Sucess),
                    "FAILED" => Some(Self::Failed),
                    _ => None,
                }
            }
        }
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum ContractResult {
            Default = 0,
            Success = 1,
            Revert = 2,
            BadJumpDestination = 3,
            OutOfMemory = 4,
            PrecompiledContract = 5,
            StackTooSmall = 6,
            StackTooLarge = 7,
            IllegalOperation = 8,
            StackOverflow = 9,
            OutOfEnergy = 10,
            OutOfTime = 11,
            JvmStackOverFlow = 12,
            Unknown = 13,
            TransferFailed = 14,
            InvalidCode = 15,
        }
        impl ContractResult {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Default => "DEFAULT",
                    Self::Success => "SUCCESS",
                    Self::Revert => "REVERT",
                    Self::BadJumpDestination => "BAD_JUMP_DESTINATION",
                    Self::OutOfMemory => "OUT_OF_MEMORY",
                    Self::PrecompiledContract => "PRECOMPILED_CONTRACT",
                    Self::StackTooSmall => "STACK_TOO_SMALL",
                    Self::StackTooLarge => "STACK_TOO_LARGE",
                    Self::IllegalOperation => "ILLEGAL_OPERATION",
                    Self::StackOverflow => "STACK_OVERFLOW",
                    Self::OutOfEnergy => "OUT_OF_ENERGY",
                    Self::OutOfTime => "OUT_OF_TIME",
                    Self::JvmStackOverFlow => "JVM_STACK_OVER_FLOW",
                    Self::Unknown => "UNKNOWN",
                    Self::TransferFailed => "TRANSFER_FAILED",
                    Self::InvalidCode => "INVALID_CODE",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "DEFAULT" => Some(Self::Default),
                    "SUCCESS" => Some(Self::Success),
                    "REVERT" => Some(Self::Revert),
                    "BAD_JUMP_DESTINATION" => Some(Self::BadJumpDestination),
                    "OUT_OF_MEMORY" => Some(Self::OutOfMemory),
                    "PRECOMPILED_CONTRACT" => Some(Self::PrecompiledContract),
                    "STACK_TOO_SMALL" => Some(Self::StackTooSmall),
                    "STACK_TOO_LARGE" => Some(Self::StackTooLarge),
                    "ILLEGAL_OPERATION" => Some(Self::IllegalOperation),
                    "STACK_OVERFLOW" => Some(Self::StackOverflow),
                    "OUT_OF_ENERGY" => Some(Self::OutOfEnergy),
                    "OUT_OF_TIME" => Some(Self::OutOfTime),
                    "JVM_STACK_OVER_FLOW" => Some(Self::JvmStackOverFlow),
                    "UNKNOWN" => Some(Self::Unknown),
                    "TRANSFER_FAILED" => Some(Self::TransferFailed),
                    "INVALID_CODE" => Some(Self::InvalidCode),
                    _ => None,
                }
            }
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Raw {
        #[prost(bytes = "vec", tag = "1")]
        pub ref_block_bytes: ::prost::alloc::vec::Vec<u8>,
        #[prost(int64, tag = "3")]
        pub ref_block_num: i64,
        #[prost(bytes = "vec", tag = "4")]
        pub ref_block_hash: ::prost::alloc::vec::Vec<u8>,
        #[prost(int64, tag = "8")]
        pub expiration: i64,
        #[prost(message, repeated, tag = "9")]
        pub auths: ::prost::alloc::vec::Vec<super::Authority>,
        /// data not used
        #[prost(bytes = "vec", tag = "10")]
        pub data: ::prost::alloc::vec::Vec<u8>,
        /// only support size = 1,  repeated list here for extension
        #[prost(message, repeated, tag = "11")]
        pub contract: ::prost::alloc::vec::Vec<Contract>,
        /// scripts not used
        #[prost(bytes = "vec", tag = "12")]
        pub scripts: ::prost::alloc::vec::Vec<u8>,
        #[prost(int64, tag = "14")]
        pub timestamp: i64,
        #[prost(int64, tag = "18")]
        pub fee_limit: i64,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransactionInfo {
    #[prost(bytes = "vec", tag = "1")]
    pub id: ::prost::alloc::vec::Vec<u8>,
    #[prost(int64, tag = "2")]
    pub fee: i64,
    #[prost(int64, tag = "3")]
    pub block_number: i64,
    #[prost(int64, tag = "4")]
    pub block_time_stamp: i64,
    #[prost(bytes = "vec", repeated, tag = "5")]
    pub contract_result: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes = "vec", tag = "6")]
    pub contract_address: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag = "7")]
    pub receipt: ::core::option::Option<ResourceReceipt>,
    #[prost(message, repeated, tag = "8")]
    pub log: ::prost::alloc::vec::Vec<transaction_info::Log>,
    #[prost(enumeration = "transaction_info::Code", tag = "9")]
    pub result: i32,
    #[prost(bytes = "vec", tag = "10")]
    pub res_message: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, tag = "14")]
    pub asset_issue_id: ::prost::alloc::string::String,
    #[prost(int64, tag = "15")]
    pub withdraw_amount: i64,
    #[prost(int64, tag = "16")]
    pub unfreeze_amount: i64,
    #[prost(message, repeated, tag = "17")]
    pub internal_transactions: ::prost::alloc::vec::Vec<InternalTransaction>,
    #[prost(int64, tag = "18")]
    pub exchange_received_amount: i64,
    #[prost(int64, tag = "19")]
    pub exchange_inject_another_amount: i64,
    #[prost(int64, tag = "20")]
    pub exchange_withdraw_another_amount: i64,
    #[prost(int64, tag = "21")]
    pub exchange_id: i64,
    #[prost(int64, tag = "22")]
    pub shielded_transaction_fee: i64,
    #[prost(bytes = "vec", tag = "25")]
    pub order_id: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, repeated, tag = "26")]
    pub order_details: ::prost::alloc::vec::Vec<MarketOrderDetail>,
    #[prost(int64, tag = "27")]
    pub packing_fee: i64,
    #[prost(int64, tag = "28")]
    pub withdraw_expire_amount: i64,
    #[prost(map = "string, int64", tag = "29")]
    pub cancel_unfreeze_v2_amount: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        i64,
    >,
}
/// Nested message and enum types in `TransactionInfo`.
pub mod transaction_info {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Log {
        #[prost(bytes = "vec", tag = "1")]
        pub address: ::prost::alloc::vec::Vec<u8>,
        #[prost(bytes = "vec", repeated, tag = "2")]
        pub topics: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
        #[prost(bytes = "vec", tag = "3")]
        pub data: ::prost::alloc::vec::Vec<u8>,
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Code {
        Sucess = 0,
        Failed = 1,
    }
    impl Code {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Sucess => "SUCESS",
                Self::Failed => "FAILED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SUCESS" => Some(Self::Sucess),
                "FAILED" => Some(Self::Failed),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransactionRet {
    #[prost(int64, tag = "1")]
    pub block_number: i64,
    #[prost(int64, tag = "2")]
    pub block_time_stamp: i64,
    #[prost(message, repeated, tag = "3")]
    pub transactioninfo: ::prost::alloc::vec::Vec<TransactionInfo>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Transactions {
    #[prost(message, repeated, tag = "1")]
    pub transactions: ::prost::alloc::vec::Vec<Transaction>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlockHeader {
    #[prost(message, optional, tag = "1")]
    pub raw_data: ::core::option::Option<block_header::Raw>,
    #[prost(bytes = "vec", tag = "2")]
    pub witness_signature: ::prost::alloc::vec::Vec<u8>,
}
/// Nested message and enum types in `BlockHeader`.
pub mod block_header {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Raw {
        #[prost(int64, tag = "1")]
        pub timestamp: i64,
        #[prost(bytes = "vec", tag = "2")]
        pub tx_trie_root: ::prost::alloc::vec::Vec<u8>,
        #[prost(bytes = "vec", tag = "3")]
        pub parent_hash: ::prost::alloc::vec::Vec<u8>,
        /// bytes nonce = 5;
        /// bytes difficulty = 6;
        #[prost(int64, tag = "7")]
        pub number: i64,
        #[prost(int64, tag = "8")]
        pub witness_id: i64,
        #[prost(bytes = "vec", tag = "9")]
        pub witness_address: ::prost::alloc::vec::Vec<u8>,
        #[prost(int32, tag = "10")]
        pub version: i32,
        #[prost(bytes = "vec", tag = "11")]
        pub account_state_root: ::prost::alloc::vec::Vec<u8>,
    }
}
/// block
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Block {
    #[prost(message, repeated, tag = "1")]
    pub transactions: ::prost::alloc::vec::Vec<Transaction>,
    #[prost(message, optional, tag = "2")]
    pub block_header: ::core::option::Option<BlockHeader>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChainInventory {
    #[prost(message, repeated, tag = "1")]
    pub ids: ::prost::alloc::vec::Vec<chain_inventory::BlockId>,
    #[prost(int64, tag = "2")]
    pub remain_num: i64,
}
/// Nested message and enum types in `ChainInventory`.
pub mod chain_inventory {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct BlockId {
        #[prost(bytes = "vec", tag = "1")]
        pub hash: ::prost::alloc::vec::Vec<u8>,
        #[prost(int64, tag = "2")]
        pub number: i64,
    }
}
/// Inventory
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlockInventory {
    #[prost(message, repeated, tag = "1")]
    pub ids: ::prost::alloc::vec::Vec<block_inventory::BlockId>,
    #[prost(enumeration = "block_inventory::Type", tag = "2")]
    pub r#type: i32,
}
/// Nested message and enum types in `BlockInventory`.
pub mod block_inventory {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct BlockId {
        #[prost(bytes = "vec", tag = "1")]
        pub hash: ::prost::alloc::vec::Vec<u8>,
        #[prost(int64, tag = "2")]
        pub number: i64,
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        Sync = 0,
        Advtise = 1,
        Fetch = 2,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Sync => "SYNC",
                Self::Advtise => "ADVTISE",
                Self::Fetch => "FETCH",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SYNC" => Some(Self::Sync),
                "ADVTISE" => Some(Self::Advtise),
                "FETCH" => Some(Self::Fetch),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Inventory {
    #[prost(enumeration = "inventory::InventoryType", tag = "1")]
    pub r#type: i32,
    #[prost(bytes = "vec", repeated, tag = "2")]
    pub ids: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
}
/// Nested message and enum types in `Inventory`.
pub mod inventory {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum InventoryType {
        Trx = 0,
        Block = 1,
    }
    impl InventoryType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Trx => "TRX",
                Self::Block => "BLOCK",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TRX" => Some(Self::Trx),
                "BLOCK" => Some(Self::Block),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Items {
    #[prost(enumeration = "items::ItemType", tag = "1")]
    pub r#type: i32,
    #[prost(message, repeated, tag = "2")]
    pub blocks: ::prost::alloc::vec::Vec<Block>,
    #[prost(message, repeated, tag = "3")]
    pub block_headers: ::prost::alloc::vec::Vec<BlockHeader>,
    #[prost(message, repeated, tag = "4")]
    pub transactions: ::prost::alloc::vec::Vec<Transaction>,
}
/// Nested message and enum types in `Items`.
pub mod items {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ItemType {
        Err = 0,
        Trx = 1,
        Block = 2,
        Blockheader = 3,
    }
    impl ItemType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Err => "ERR",
                Self::Trx => "TRX",
                Self::Block => "BLOCK",
                Self::Blockheader => "BLOCKHEADER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ERR" => Some(Self::Err),
                "TRX" => Some(Self::Trx),
                "BLOCK" => Some(Self::Block),
                "BLOCKHEADER" => Some(Self::Blockheader),
                _ => None,
            }
        }
    }
}
/// DynamicProperties
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DynamicProperties {
    #[prost(int64, tag = "1")]
    pub last_solidity_block_num: i64,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DisconnectMessage {
    #[prost(enumeration = "ReasonCode", tag = "1")]
    pub reason: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InternalTransaction {
    /// internalTransaction identity, the root InternalTransaction hash
    /// should equals to root transaction id.
    #[prost(bytes = "vec", tag = "1")]
    pub hash: ::prost::alloc::vec::Vec<u8>,
    /// the one send trx (TBD: or token) via function
    #[prost(bytes = "vec", tag = "2")]
    pub caller_address: ::prost::alloc::vec::Vec<u8>,
    /// the one recieve trx (TBD: or token) via function
    #[prost(bytes = "vec", tag = "3")]
    pub transfer_to_address: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, repeated, tag = "4")]
    pub call_value_info: ::prost::alloc::vec::Vec<internal_transaction::CallValueInfo>,
    #[prost(bytes = "vec", tag = "5")]
    pub note: ::prost::alloc::vec::Vec<u8>,
    #[prost(bool, tag = "6")]
    pub rejected: bool,
    #[prost(string, tag = "7")]
    pub extra: ::prost::alloc::string::String,
}
/// Nested message and enum types in `InternalTransaction`.
pub mod internal_transaction {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CallValueInfo {
        /// trx (TBD: or token) value
        #[prost(int64, tag = "1")]
        pub call_value: i64,
        /// TBD: tokenName, trx should be empty
        #[prost(string, tag = "2")]
        pub token_id: ::prost::alloc::string::String,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DelegatedResourceAccountIndex {
    #[prost(bytes = "vec", tag = "1")]
    pub account: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", repeated, tag = "2")]
    pub from_accounts: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes = "vec", repeated, tag = "3")]
    pub to_accounts: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    #[prost(int64, tag = "4")]
    pub timestamp: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NodeInfo {
    #[prost(int64, tag = "1")]
    pub begin_sync_num: i64,
    #[prost(string, tag = "2")]
    pub block: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub solidity_block: ::prost::alloc::string::String,
    /// connect information
    #[prost(int32, tag = "4")]
    pub current_connect_count: i32,
    #[prost(int32, tag = "5")]
    pub active_connect_count: i32,
    #[prost(int32, tag = "6")]
    pub passive_connect_count: i32,
    #[prost(int64, tag = "7")]
    pub total_flow: i64,
    #[prost(message, repeated, tag = "8")]
    pub peer_info_list: ::prost::alloc::vec::Vec<node_info::PeerInfo>,
    #[prost(message, optional, tag = "9")]
    pub config_node_info: ::core::option::Option<node_info::ConfigNodeInfo>,
    #[prost(message, optional, tag = "10")]
    pub machine_info: ::core::option::Option<node_info::MachineInfo>,
    #[prost(map = "string, string", tag = "11")]
    pub cheat_witness_info_map: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// Nested message and enum types in `NodeInfo`.
pub mod node_info {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PeerInfo {
        #[prost(string, tag = "1")]
        pub last_sync_block: ::prost::alloc::string::String,
        #[prost(int64, tag = "2")]
        pub remain_num: i64,
        #[prost(int64, tag = "3")]
        pub last_block_update_time: i64,
        #[prost(bool, tag = "4")]
        pub sync_flag: bool,
        #[prost(int64, tag = "5")]
        pub head_block_time_we_both_have: i64,
        #[prost(bool, tag = "6")]
        pub need_sync_from_peer: bool,
        #[prost(bool, tag = "7")]
        pub need_sync_from_us: bool,
        #[prost(string, tag = "8")]
        pub host: ::prost::alloc::string::String,
        #[prost(int32, tag = "9")]
        pub port: i32,
        #[prost(string, tag = "10")]
        pub node_id: ::prost::alloc::string::String,
        #[prost(int64, tag = "11")]
        pub connect_time: i64,
        #[prost(double, tag = "12")]
        pub avg_latency: f64,
        #[prost(int32, tag = "13")]
        pub sync_to_fetch_size: i32,
        #[prost(int64, tag = "14")]
        pub sync_to_fetch_size_peek_num: i64,
        #[prost(int32, tag = "15")]
        pub sync_block_requested_size: i32,
        #[prost(int64, tag = "16")]
        pub un_fetch_syn_num: i64,
        #[prost(int32, tag = "17")]
        pub block_in_porc_size: i32,
        #[prost(string, tag = "18")]
        pub head_block_we_both_have: ::prost::alloc::string::String,
        #[prost(bool, tag = "19")]
        pub is_active: bool,
        #[prost(int32, tag = "20")]
        pub score: i32,
        #[prost(int32, tag = "21")]
        pub node_count: i32,
        #[prost(int64, tag = "22")]
        pub in_flow: i64,
        #[prost(int32, tag = "23")]
        pub disconnect_times: i32,
        #[prost(string, tag = "24")]
        pub local_disconnect_reason: ::prost::alloc::string::String,
        #[prost(string, tag = "25")]
        pub remote_disconnect_reason: ::prost::alloc::string::String,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ConfigNodeInfo {
        #[prost(string, tag = "1")]
        pub code_version: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub p2p_version: ::prost::alloc::string::String,
        #[prost(int32, tag = "3")]
        pub listen_port: i32,
        #[prost(bool, tag = "4")]
        pub discover_enable: bool,
        #[prost(int32, tag = "5")]
        pub active_node_size: i32,
        #[prost(int32, tag = "6")]
        pub passive_node_size: i32,
        #[prost(int32, tag = "7")]
        pub send_node_size: i32,
        #[prost(int32, tag = "8")]
        pub max_connect_count: i32,
        #[prost(int32, tag = "9")]
        pub same_ip_max_connect_count: i32,
        #[prost(int32, tag = "10")]
        pub backup_listen_port: i32,
        #[prost(int32, tag = "11")]
        pub backup_member_size: i32,
        #[prost(int32, tag = "12")]
        pub backup_priority: i32,
        #[prost(int32, tag = "13")]
        pub db_version: i32,
        #[prost(int32, tag = "14")]
        pub min_participation_rate: i32,
        #[prost(bool, tag = "15")]
        pub support_constant: bool,
        #[prost(double, tag = "16")]
        pub min_time_ratio: f64,
        #[prost(double, tag = "17")]
        pub max_time_ratio: f64,
        #[prost(int64, tag = "18")]
        pub allow_creation_of_contracts: i64,
        #[prost(int64, tag = "19")]
        pub allow_adaptive_energy: i64,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct MachineInfo {
        #[prost(int32, tag = "1")]
        pub thread_count: i32,
        #[prost(int32, tag = "2")]
        pub dead_lock_thread_count: i32,
        #[prost(int32, tag = "3")]
        pub cpu_count: i32,
        #[prost(int64, tag = "4")]
        pub total_memory: i64,
        #[prost(int64, tag = "5")]
        pub free_memory: i64,
        #[prost(double, tag = "6")]
        pub cpu_rate: f64,
        #[prost(string, tag = "7")]
        pub java_version: ::prost::alloc::string::String,
        #[prost(string, tag = "8")]
        pub os_name: ::prost::alloc::string::String,
        #[prost(int64, tag = "9")]
        pub jvm_total_memory: i64,
        #[prost(int64, tag = "10")]
        pub jvm_free_memory: i64,
        #[prost(double, tag = "11")]
        pub process_cpu_rate: f64,
        #[prost(message, repeated, tag = "12")]
        pub memory_desc_info_list: ::prost::alloc::vec::Vec<
            machine_info::MemoryDescInfo,
        >,
        #[prost(message, repeated, tag = "13")]
        pub dead_lock_thread_info_list: ::prost::alloc::vec::Vec<
            machine_info::DeadLockThreadInfo,
        >,
    }
    /// Nested message and enum types in `MachineInfo`.
    pub mod machine_info {
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct MemoryDescInfo {
            #[prost(string, tag = "1")]
            pub name: ::prost::alloc::string::String,
            #[prost(int64, tag = "2")]
            pub init_size: i64,
            #[prost(int64, tag = "3")]
            pub use_size: i64,
            #[prost(int64, tag = "4")]
            pub max_size: i64,
            #[prost(double, tag = "5")]
            pub use_rate: f64,
        }
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct DeadLockThreadInfo {
            #[prost(string, tag = "1")]
            pub name: ::prost::alloc::string::String,
            #[prost(string, tag = "2")]
            pub lock_name: ::prost::alloc::string::String,
            #[prost(string, tag = "3")]
            pub lock_owner: ::prost::alloc::string::String,
            #[prost(string, tag = "4")]
            pub state: ::prost::alloc::string::String,
            #[prost(int64, tag = "5")]
            pub block_time: i64,
            #[prost(int64, tag = "6")]
            pub wait_time: i64,
            #[prost(string, tag = "7")]
            pub stack_trace: ::prost::alloc::string::String,
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetricsInfo {
    #[prost(int64, tag = "1")]
    pub interval: i64,
    #[prost(message, optional, tag = "2")]
    pub node: ::core::option::Option<metrics_info::NodeInfo>,
    #[prost(message, optional, tag = "3")]
    pub blockchain: ::core::option::Option<metrics_info::BlockChainInfo>,
    #[prost(message, optional, tag = "4")]
    pub net: ::core::option::Option<metrics_info::NetInfo>,
}
/// Nested message and enum types in `MetricsInfo`.
pub mod metrics_info {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct NodeInfo {
        #[prost(string, tag = "1")]
        pub ip: ::prost::alloc::string::String,
        #[prost(int32, tag = "2")]
        pub node_type: i32,
        #[prost(string, tag = "3")]
        pub version: ::prost::alloc::string::String,
        #[prost(int32, tag = "4")]
        pub backup_status: i32,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct BlockChainInfo {
        #[prost(int64, tag = "1")]
        pub head_block_num: i64,
        #[prost(int64, tag = "2")]
        pub head_block_timestamp: i64,
        #[prost(string, tag = "3")]
        pub head_block_hash: ::prost::alloc::string::String,
        #[prost(int32, tag = "4")]
        pub fork_count: i32,
        #[prost(int32, tag = "5")]
        pub fail_fork_count: i32,
        #[prost(message, optional, tag = "6")]
        pub block_process_time: ::core::option::Option<RateInfo>,
        #[prost(message, optional, tag = "7")]
        pub tps: ::core::option::Option<RateInfo>,
        #[prost(int32, tag = "8")]
        pub transaction_cache_size: i32,
        #[prost(message, optional, tag = "9")]
        pub missed_transaction: ::core::option::Option<RateInfo>,
        #[prost(message, repeated, tag = "10")]
        pub witnesses: ::prost::alloc::vec::Vec<block_chain_info::Witness>,
        #[prost(int64, tag = "11")]
        pub fail_process_block_num: i64,
        #[prost(string, tag = "12")]
        pub fail_process_block_reason: ::prost::alloc::string::String,
        #[prost(message, repeated, tag = "13")]
        pub dup_witness: ::prost::alloc::vec::Vec<block_chain_info::DupWitness>,
    }
    /// Nested message and enum types in `BlockChainInfo`.
    pub mod block_chain_info {
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Witness {
            #[prost(string, tag = "1")]
            pub address: ::prost::alloc::string::String,
            #[prost(int32, tag = "2")]
            pub version: i32,
        }
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct DupWitness {
            #[prost(string, tag = "1")]
            pub address: ::prost::alloc::string::String,
            #[prost(int64, tag = "2")]
            pub block_num: i64,
            #[prost(int32, tag = "3")]
            pub count: i32,
        }
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct RateInfo {
        #[prost(int64, tag = "1")]
        pub count: i64,
        #[prost(double, tag = "2")]
        pub mean_rate: f64,
        #[prost(double, tag = "3")]
        pub one_minute_rate: f64,
        #[prost(double, tag = "4")]
        pub five_minute_rate: f64,
        #[prost(double, tag = "5")]
        pub fifteen_minute_rate: f64,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct NetInfo {
        #[prost(int32, tag = "1")]
        pub error_proto_count: i32,
        #[prost(message, optional, tag = "2")]
        pub api: ::core::option::Option<net_info::ApiInfo>,
        #[prost(int32, tag = "3")]
        pub connection_count: i32,
        #[prost(int32, tag = "4")]
        pub valid_connection_count: i32,
        #[prost(message, optional, tag = "5")]
        pub tcp_in_traffic: ::core::option::Option<RateInfo>,
        #[prost(message, optional, tag = "6")]
        pub tcp_out_traffic: ::core::option::Option<RateInfo>,
        #[prost(int32, tag = "7")]
        pub disconnection_count: i32,
        #[prost(message, repeated, tag = "8")]
        pub disconnection_detail: ::prost::alloc::vec::Vec<
            net_info::DisconnectionDetailInfo,
        >,
        #[prost(message, optional, tag = "9")]
        pub udp_in_traffic: ::core::option::Option<RateInfo>,
        #[prost(message, optional, tag = "10")]
        pub udp_out_traffic: ::core::option::Option<RateInfo>,
        #[prost(message, optional, tag = "11")]
        pub latency: ::core::option::Option<net_info::LatencyInfo>,
    }
    /// Nested message and enum types in `NetInfo`.
    pub mod net_info {
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct ApiInfo {
            #[prost(message, optional, tag = "1")]
            pub qps: ::core::option::Option<super::RateInfo>,
            #[prost(message, optional, tag = "2")]
            pub fail_qps: ::core::option::Option<super::RateInfo>,
            #[prost(message, optional, tag = "3")]
            pub out_traffic: ::core::option::Option<super::RateInfo>,
            #[prost(message, repeated, tag = "4")]
            pub detail: ::prost::alloc::vec::Vec<api_info::ApiDetailInfo>,
        }
        /// Nested message and enum types in `ApiInfo`.
        pub mod api_info {
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct ApiDetailInfo {
                #[prost(string, tag = "1")]
                pub name: ::prost::alloc::string::String,
                #[prost(message, optional, tag = "2")]
                pub qps: ::core::option::Option<super::super::RateInfo>,
                #[prost(message, optional, tag = "3")]
                pub fail_qps: ::core::option::Option<super::super::RateInfo>,
                #[prost(message, optional, tag = "4")]
                pub out_traffic: ::core::option::Option<super::super::RateInfo>,
            }
        }
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct DisconnectionDetailInfo {
            #[prost(string, tag = "1")]
            pub reason: ::prost::alloc::string::String,
            #[prost(int32, tag = "2")]
            pub count: i32,
        }
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct LatencyInfo {
            #[prost(int32, tag = "1")]
            pub top99: i32,
            #[prost(int32, tag = "2")]
            pub top95: i32,
            #[prost(int32, tag = "3")]
            pub top75: i32,
            #[prost(int32, tag = "4")]
            pub total_count: i32,
            #[prost(int32, tag = "5")]
            pub delay1_s: i32,
            #[prost(int32, tag = "6")]
            pub delay2_s: i32,
            #[prost(int32, tag = "7")]
            pub delay3_s: i32,
            #[prost(message, repeated, tag = "8")]
            pub detail: ::prost::alloc::vec::Vec<latency_info::LatencyDetailInfo>,
        }
        /// Nested message and enum types in `LatencyInfo`.
        pub mod latency_info {
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct LatencyDetailInfo {
                #[prost(string, tag = "1")]
                pub witness: ::prost::alloc::string::String,
                #[prost(int32, tag = "2")]
                pub top99: i32,
                #[prost(int32, tag = "3")]
                pub top95: i32,
                #[prost(int32, tag = "4")]
                pub top75: i32,
                #[prost(int32, tag = "5")]
                pub count: i32,
                #[prost(int32, tag = "6")]
                pub delay1_s: i32,
                #[prost(int32, tag = "7")]
                pub delay2_s: i32,
                #[prost(int32, tag = "8")]
                pub delay3_s: i32,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PbftMessage {
    #[prost(message, optional, tag = "1")]
    pub raw_data: ::core::option::Option<pbft_message::Raw>,
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
}
/// Nested message and enum types in `PBFTMessage`.
pub mod pbft_message {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Raw {
        #[prost(enumeration = "MsgType", tag = "1")]
        pub msg_type: i32,
        #[prost(enumeration = "DataType", tag = "2")]
        pub data_type: i32,
        #[prost(int64, tag = "3")]
        pub view_n: i64,
        #[prost(int64, tag = "4")]
        pub epoch: i64,
        #[prost(bytes = "vec", tag = "5")]
        pub data: ::prost::alloc::vec::Vec<u8>,
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MsgType {
        ViewChange = 0,
        Request = 1,
        Preprepare = 2,
        Prepare = 3,
        Commit = 4,
    }
    impl MsgType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::ViewChange => "VIEW_CHANGE",
                Self::Request => "REQUEST",
                Self::Preprepare => "PREPREPARE",
                Self::Prepare => "PREPARE",
                Self::Commit => "COMMIT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "VIEW_CHANGE" => Some(Self::ViewChange),
                "REQUEST" => Some(Self::Request),
                "PREPREPARE" => Some(Self::Preprepare),
                "PREPARE" => Some(Self::Prepare),
                "COMMIT" => Some(Self::Commit),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DataType {
        Block = 0,
        Srl = 1,
    }
    impl DataType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Block => "BLOCK",
                Self::Srl => "SRL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "BLOCK" => Some(Self::Block),
                "SRL" => Some(Self::Srl),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PbftCommitResult {
    #[prost(bytes = "vec", tag = "1")]
    pub data: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", repeated, tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Srl {
    #[prost(bytes = "vec", repeated, tag = "1")]
    pub sr_address: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AccountType {
    Normal = 0,
    AssetIssue = 1,
    Contract = 2,
}
impl AccountType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Normal => "Normal",
            Self::AssetIssue => "AssetIssue",
            Self::Contract => "Contract",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "Normal" => Some(Self::Normal),
            "AssetIssue" => Some(Self::AssetIssue),
            "Contract" => Some(Self::Contract),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ReasonCode {
    Requested = 0,
    BadProtocol = 2,
    TooManyPeers = 4,
    DuplicatePeer = 5,
    IncompatibleProtocol = 6,
    RandomElimination = 7,
    PeerQuiting = 8,
    UnexpectedIdentity = 9,
    LocalIdentity = 10,
    PingTimeout = 11,
    UserReason = 16,
    Reset = 17,
    SyncFail = 18,
    FetchFail = 19,
    BadTx = 20,
    BadBlock = 21,
    Forked = 22,
    Unlinkable = 23,
    IncompatibleVersion = 24,
    IncompatibleChain = 25,
    TimeOut = 32,
    ConnectFail = 33,
    TooManyPeersWithSameIp = 34,
    LightNodeSyncFail = 35,
    BelowThanMe = 36,
    NotWitness = 37,
    NoSuchMessage = 38,
    Unknown = 255,
}
impl ReasonCode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Requested => "REQUESTED",
            Self::BadProtocol => "BAD_PROTOCOL",
            Self::TooManyPeers => "TOO_MANY_PEERS",
            Self::DuplicatePeer => "DUPLICATE_PEER",
            Self::IncompatibleProtocol => "INCOMPATIBLE_PROTOCOL",
            Self::RandomElimination => "RANDOM_ELIMINATION",
            Self::PeerQuiting => "PEER_QUITING",
            Self::UnexpectedIdentity => "UNEXPECTED_IDENTITY",
            Self::LocalIdentity => "LOCAL_IDENTITY",
            Self::PingTimeout => "PING_TIMEOUT",
            Self::UserReason => "USER_REASON",
            Self::Reset => "RESET",
            Self::SyncFail => "SYNC_FAIL",
            Self::FetchFail => "FETCH_FAIL",
            Self::BadTx => "BAD_TX",
            Self::BadBlock => "BAD_BLOCK",
            Self::Forked => "FORKED",
            Self::Unlinkable => "UNLINKABLE",
            Self::IncompatibleVersion => "INCOMPATIBLE_VERSION",
            Self::IncompatibleChain => "INCOMPATIBLE_CHAIN",
            Self::TimeOut => "TIME_OUT",
            Self::ConnectFail => "CONNECT_FAIL",
            Self::TooManyPeersWithSameIp => "TOO_MANY_PEERS_WITH_SAME_IP",
            Self::LightNodeSyncFail => "LIGHT_NODE_SYNC_FAIL",
            Self::BelowThanMe => "BELOW_THAN_ME",
            Self::NotWitness => "NOT_WITNESS",
            Self::NoSuchMessage => "NO_SUCH_MESSAGE",
            Self::Unknown => "UNKNOWN",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "REQUESTED" => Some(Self::Requested),
            "BAD_PROTOCOL" => Some(Self::BadProtocol),
            "TOO_MANY_PEERS" => Some(Self::TooManyPeers),
            "DUPLICATE_PEER" => Some(Self::DuplicatePeer),
            "INCOMPATIBLE_PROTOCOL" => Some(Self::IncompatibleProtocol),
            "RANDOM_ELIMINATION" => Some(Self::RandomElimination),
            "PEER_QUITING" => Some(Self::PeerQuiting),
            "UNEXPECTED_IDENTITY" => Some(Self::UnexpectedIdentity),
            "LOCAL_IDENTITY" => Some(Self::LocalIdentity),
            "PING_TIMEOUT" => Some(Self::PingTimeout),
            "USER_REASON" => Some(Self::UserReason),
            "RESET" => Some(Self::Reset),
            "SYNC_FAIL" => Some(Self::SyncFail),
            "FETCH_FAIL" => Some(Self::FetchFail),
            "BAD_TX" => Some(Self::BadTx),
            "BAD_BLOCK" => Some(Self::BadBlock),
            "FORKED" => Some(Self::Forked),
            "UNLINKABLE" => Some(Self::Unlinkable),
            "INCOMPATIBLE_VERSION" => Some(Self::IncompatibleVersion),
            "INCOMPATIBLE_CHAIN" => Some(Self::IncompatibleChain),
            "TIME_OUT" => Some(Self::TimeOut),
            "CONNECT_FAIL" => Some(Self::ConnectFail),
            "TOO_MANY_PEERS_WITH_SAME_IP" => Some(Self::TooManyPeersWithSameIp),
            "LIGHT_NODE_SYNC_FAIL" => Some(Self::LightNodeSyncFail),
            "BELOW_THAN_ME" => Some(Self::BelowThanMe),
            "NOT_WITNESS" => Some(Self::NotWitness),
            "NO_SUCH_MESSAGE" => Some(Self::NoSuchMessage),
            "UNKNOWN" => Some(Self::Unknown),
            _ => None,
        }
    }
}
